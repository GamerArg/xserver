package com.mickare.xserver.socket;

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.PriorityQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import javax.net.SocketFactory;

import com.mickare.xserver.Exception.NotInitializedException;
import com.mickare.xserver.message.LoginMessage;
import com.mickare.xserver.message.Message;
import com.mickare.xserver.message.MessageFactory;
import com.mickare.xserver.util.Encryption;

public class CopyOfXRemoteServer implements Runnable {

	private static SocketFactory sf = SocketFactory.getDefault();
	
	private static final int BUFFER_SIZE = 64;
	
	private final Lock lock = new ReentrantLock();
	
	// Infos
	private final String name;
	private final String host;
	private final int port;
	private final String password;
	
	// Connection
	private Socket socket = null;
	private volatile ConnectionStatus status = ConnectionStatus.DISCONNECTED;
	private boolean initiator = false;
	private boolean logged_in = false;
	
	private DataOutputStream streamOut = null;
	private DataInputStream streamIn = null;
	
	
	private Thread inThread = null; 
	private outGoing outThread = null;
	
	private final ConcurrentLinkedQueue<Message> messageQueue = new ConcurrentLinkedQueue<Message>();
	
	
	// Constructor
	public CopyOfXRemoteServer(String name, String host, int port, String password) {
		this.name = name;
		this.host = host;
		this.port = port;
		this.password = Encryption.MD5(password);
	}

	// Info Getters
	public String getName() {
		return name;
	}

	public String getHost() {
		return host;
	}

	public int getPort() {
		return port;
	}

	public String getPassword() {
		return password;
	}
	
	// Socket
	public boolean isClosed() {
		if(socket == null) {
			return false;
		}
		return socket.isClosed();
	}
	
	public final ConnectionStatus getConnectionStatus() {
		return  status;
	}
	
	// Methods
	
	public void send(Message m) {
		lock.lock();
		messageQueue.add(m);
		lock.unlock();
		messageQueue.notify();
	}
	
	protected void start() {
		if(inThread == null) {
			inThread = new Thread(this);
			inThread.start();
		}
		if(outThread == null) {
			outThread = new outGoing(this);
			outThread.start();
		}
	}
	
	// Connection Methods
	protected synchronized void open() throws UnknownHostException, IOException, NotInitializedException {
		changeConnectionStatus(ConnectionStatus.DISCONNECTED);
		if(socket != null) {
			if(socket.isClosed()) {
				socket = sf.createSocket(host, port);
			}
		} else {
			socket = sf.createSocket(host, port);
		}

		streamOut = new DataOutputStream(socket.getOutputStream());
		streamIn = new DataInputStream(socket.getInputStream());
				
		lock.lock();
		initiator = true;
		logged_in = false;
		lock.unlock();
		changeConnectionStatus(ConnectionStatus.LOGIN_SENDING);

	}
	
	protected synchronized void open(Socket asocket) throws IOException, NotInitializedException {
		changeConnectionStatus(ConnectionStatus.DISCONNECTED);
		if(asocket != null && !asocket.isClosed()) {
			if(socket == null || socket.isClosed()) {
				close();
				socket = asocket;
			}
		}
		
		streamOut = new DataOutputStream(socket.getOutputStream());
		streamIn = new DataInputStream(socket.getInputStream());
				
		lock.lock();
		initiator = false;
		logged_in = false;
		lock.unlock();
		changeConnectionStatus(ConnectionStatus.RECEIVING);
				
	}
	
	protected synchronized void close() throws IOException {
		if(streamOut != null) {
			streamOut.close();
			streamOut = null;
		}
		if(socket != null) {
			socket.close();
			socket = null;
		}
		inThread.interrupt();	
		outThread.interrupt();
	}
			
	private void changeConnectionStatus(ConnectionStatus s) {
		lock.lock();
		status = s;
		lock.unlock();
		status.notifyAll();
	}
	
	private int bufferLength = -1;
	
	@Override
	public void run() {
		while(!Thread.interrupted()) {
			try {
				if(!status.equals(ConnectionStatus.CONNECTED) && !status.equals(ConnectionStatus.RECEIVING)) {
					status.wait();
				} else {
					try {
						if(bufferLength < 0) {
							bufferLength = streamIn.readInt();
						} else if(status.equals(ConnectionStatus.CONNECTED)){
							changeConnectionStatus(ConnectionStatus.RECEIVING);
						} else if(status.equals(ConnectionStatus.RECEIVING)) {
							byte[] buffer = new byte[bufferLength];
		
							streamIn.readFully(buffer, 0, bufferLength);
							
							changeConnectionStatus(ConnectionStatus.CONNECTED);
							bufferLength = -1;
						} else {
							 if(status.equals(ConnectionStatus.ERROR));
							 bufferLength = -1;
						}
						 
						
					} catch (IOException e) {
						changeConnectionStatus(ConnectionStatus.ERROR);
						bufferLength = -1;
					}
				}
			
			} catch (InterruptedException e) {
				changeConnectionStatus(ConnectionStatus.DISCONNECTED);
				bufferLength = -1;
				try {
					close();
				} catch (IOException e1) {
				}
			}
		}
	}
	
	private static class outGoing extends Thread {

		private final CopyOfXRemoteServer parent;
		
		public outGoing(CopyOfXRemoteServer parent) {
			this.parent = parent;
		}

		@Override
		public void run() {
			while(!Thread.interrupted()) {
				try {
				if(parent.messageQueue.isEmpty()) {								
						parent.messageQueue.wait();
				} else {
					try {
						if(!parent.status.equals(ConnectionStatus.CONNECTED) && !parent.status.equals(ConnectionStatus.SENDING) && !parent.status.equals(ConnectionStatus.LOGIN_SENDING)) {
							parent.status.wait();
						} else if(parent.status.equals(ConnectionStatus.LOGIN_SENDING)) {
							try {
								LoginMessage lm = MessageFactory.getInstance().createLoginMessage(parent);
								
								byte[] data = lm.getData();
								parent.streamOut.writeInt(data.length);
								parent.streamOut.write(data);
								parent.streamOut.flush();
							} catch (NotInitializedException e) {
								parent.changeConnectionStatus(ConnectionStatus.ERROR);
							}						
						} else if(parent.status.equals(ConnectionStatus.CONNECTED)) {
							parent.changeConnectionStatus(ConnectionStatus.SENDING);						
						} else if(parent.status.equals(ConnectionStatus.SENDING)) {						
							Message m = parent.messageQueue.poll();
							byte[] data = m.getData();
							
							parent.streamOut.writeInt(data.length);
							parent.streamOut.write(data);
							parent.streamOut.flush();
							
							parent.changeConnectionStatus(ConnectionStatus.CONNECTED);
							
						} else {
							parent.changeConnectionStatus(ConnectionStatus.ERROR);	
						}
					} catch (IOException e) {
						parent.changeConnectionStatus(ConnectionStatus.CONNECTED);
					}
				}
				} catch (InterruptedException e) {
					parent.changeConnectionStatus(ConnectionStatus.DISCONNECTED);
					try {
						parent.close();
					} catch (IOException e1) {
					}
				}
			}
		}
		
		
	}
	
	
}
